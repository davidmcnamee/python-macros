"""
Heads up: this file makes heavy use of `ast` and `inspect` to parse
and modify python code. Most of this is done on mutable data structures.

It also uses the [executing](https://github.com/alexmojaki/executing)
library in places where we want to tie the results of an `inspect` frame back
to the corresponding `ast` node. ðŸ§‘â€ðŸ³
"""

import ast
import importlib
import inspect
import re
import sys
from pathlib import Path
from typing import (
    Any,
    Callable,
    Concatenate,
    Iterable,
    ParamSpec,
    TypeVar,
)

from executing.executing import EnhancedAST, Source

FILE_PREFIX = '''
"""
THIS FILE IS GENERATED BY A MACRO. DO NOT EDIT.
"""
import typing
'''.lstrip()

FILE_TEMPLATE = """
if typing.TYPE_CHECKING:
    pass
else:
    pass
""".lstrip()

generated_files = set[Path]()

P = ParamSpec("P")
T = TypeVar("T")


def one_or_none(it: Iterable[T]) -> T | None:
    iterator = iter(it)
    first = next(iterator, None)

    class Sentinel:
        pass

    SENTINEL = Sentinel()
    assert (
        next(iterator, SENTINEL) is SENTINEL
    ), "found more than one result when one or none was expected"
    return first


def first_or_none(it: Iterable[T]) -> T | None:
    return next(iter(it))


# def swapped_with[F: Callable[..., Any] | property](
#     gen: F,
# ) -> Callable[[Callable[..., Any] | property], F]:
#     # TODO: remove the callsite @swapped_with decorator if class doesn't have `@my_macro` decorator
#     def decorator(source_func: Callable[..., Any] | property) -> F:
#         return cast(F, source_func)

#     return decorator


# def macro_subclass[C: type](gen: C) -> Callable[[type], C]:
#     def decorator(source_class: type) -> C:
#         return cast(C, source_class)

#     return decorator


# this code is gross, badly needs a refactor
def macro[**P](proc_macro_func: Callable[Concatenate[str, P], str]):
    def decorator_func[T](
        gen: T | None = None, *args: P.args, **kwargs: P.kwargs
    ) -> Callable[..., T]:
        decorator_func_callsite = Source.executing(inspect.stack()[-3].frame)
        callsite_ast = decorator_func_callsite.node
        assert isinstance(
            callsite_ast, ast.Call
        ), "macro decorators must be called directly!"

        # TODO: could use `__session__ or __vsc_ipynb_file__` to determine file name of jupyter notebook
        # https://github.com/jupyterlab/jupyterlab/issues/16282

        def decorator(func_or_class: Callable[..., Any] | type) -> T:
            source_code = inspect.getsource(decorator_func_callsite.frame)
            insert_statements: list[tuple[int, str]] = sorted(
                [
                    *maybe_insert_gen_kwarg_to_callsite_func_decorator(
                        func_or_class, callsite_ast, source_code
                    ),
                    *maybe_insert_imports_to_macro_type_stubs(
                        func_or_class, callsite_ast, source_code
                    ),
                ],
                reverse=True,
            )

            for pos, insert_str in insert_statements:
                source_code = source_code[:pos] + insert_str + source_code[pos:]

            new_code = proc_macro_func(
                inspect.getsource(func_or_class), *args, **kwargs
            )
            try:
                new_node = ast.parse(new_code)
                remove_all_macro_decorator_callsites(new_node, callsite_ast)
                copy_all_absolute_imports(source_code, new_node)
                convert_to_generated_name(new_node, func_or_class)
            except Exception as e:
                raise ValueError(
                    "Could not parse macro-generated code as valid python code"
                ) from e

            templ_module = ast.parse(FILE_TEMPLATE)
            assert isinstance(templ_if_stmt := templ_module.body[-1], ast.If)
            try:

                def is_not_pass(node: ast.stmt) -> bool:
                    return not isinstance(node, ast.Pass)

                templ_if_stmt.body = list(filter(is_not_pass, templ_if_stmt.body))
                templ_if_stmt.orelse = list(filter(is_not_pass, templ_if_stmt.orelse))
            except ValueError:
                pass
            templ_if_stmt.body.extend(new_node.body)
            if isinstance(func_or_class, type):
                templ_if_stmt.orelse.extend(
                    ast.parse(f"class {get_generated_name(func_or_class)}: pass").body
                )
            else:
                templ_if_stmt.orelse.extend(
                    ast.parse(f"{get_generated_name(func_or_class)} = None").body
                )

            global generated_files
            macro_dir = (
                Path(decorator_func_callsite.frame.f_code.co_filename).parent
                / "__macros__"
            )
            if not macro_dir.exists():
                macro_dir.mkdir(parents=True)
            stub_path = macro_dir / "types.py"
            runtime_path = macro_dir / f"{func_or_class.__name__}.py"

            if stub_path not in generated_files:
                with stub_path.open("w") as f:
                    f.write(FILE_PREFIX)
                generated_files.add(stub_path)

            with stub_path.open("a") as f:
                f.write(ast.unparse(templ_module) + "\n\n")

            with runtime_path.open("w") as f:
                f.write(FILE_PREFIX + ast.unparse(new_node) + "\n\n")

            new_module = import_from_path(
                f".__macros__.{func_or_class.__name__}",
                runtime_path.as_posix(),
            )

            with open(decorator_func_callsite.frame.f_code.co_filename, "w") as f:
                f.write(source_code)
            return getattr(new_module, get_generated_name(func_or_class))

        return decorator

    return decorator_func


def remove_all_macro_decorator_callsites(
    root_node: ast.Module, decorator_ast: ast.Call
) -> None:
    for node in ast.walk(root_node):
        if isinstance(node, ast.FunctionDef | ast.ClassDef):
            for dec in reversed(node.decorator_list):
                if isinstance(dec, ast.Call) and ast.unparse(dec) == ast.unparse(
                    decorator_ast
                ):
                    node.decorator_list.remove(dec)


def remove_all_generated_subclasses(
    root_node: ast.Module, func_or_class: Callable[..., Any] | type
) -> None:
    for node in ast.walk(root_node):
        if isinstance(node, ast.ClassDef) and node.name == func_or_class.__name__:
            for base in reversed(node.bases):
                print("base", ast.unparse(base), get_generated_name(func_or_class))
                if ast.unparse(base) == get_generated_name(func_or_class):
                    node.bases.remove(base)


def is_absolute_import(node: ast.stmt) -> bool:
    return (isinstance(node, ast.ImportFrom) and node.level == 0) or isinstance(
        node, ast.Import
    )


def convert_to_generated_name(
    node: ast.Module, func_or_class: Callable[..., Any] | type
) -> None:
    for child in ast.walk(node):
        if isinstance(child, ast.FunctionDef | ast.ClassDef) and child.name == str(
            func_or_class.__name__
        ):
            child.name = get_generated_name(func_or_class)


def copy_all_absolute_imports(source_code: str, new_node: ast.Module) -> None:
    for node in ast.parse(source_code).body:
        if is_absolute_import(node) or (
            isinstance(node, ast.If)
            # sometimes top-level if statements contain imports (like `if TYPE_CHECKING:`)
            and any(is_absolute_import(child) for child in node.body)
        ):
            new_node.body.insert(0, node)


def get_file_pos_from_line_col(lineno: int, col_offset: int, file_contents: str) -> int:
    lineno -= 1  # adjust for zero-index
    # (weirdly, col_offset is already zero-indexed by ast library)
    lines = file_contents.splitlines(keepends=True)
    return sum(len(line) for line in lines[:lineno]) + col_offset


def maybe_insert_imports_to_macro_type_stubs(
    func_or_class: Callable[..., Any] | type,
    callsite_ast: EnhancedAST,
    source_code: str,
):
    assert isinstance(callsite_ast, ast.Call)
    generated_name = get_generated_name(func_or_class)
    for node in ast.parse(source_code).body:
        if not is_absolute_import(node) and re.search(
            r"(\W|^)" + generated_name + r"(\W|$)", ast.unparse(node)
        ):
            return  # early return if already imported
    yield 0, f"from .__macros__.types import {generated_name}\n"


def maybe_insert_gen_kwarg_to_callsite_func_decorator(
    func_or_class: Callable[..., Any] | type,
    callsite_ast: EnhancedAST,
    source_code: str,
):
    """
    In cases where we're decorating a function, we need to insert the `gen=...` kwarg
    so that your code editor can use the macro-generated code for type checking.

    Note: avoiding `ast.unparse(...)` because it won't preserve comments or whitespace.
    """
    assert isinstance(callsite_ast, ast.Call)
    if isinstance(
        callsite_ast.parent, ast.FunctionDef | ast.ClassDef
    ) and not one_or_none(
        kwarg for kwarg in callsite_ast.keywords if kwarg.arg == "gen"
    ):
        first_kwarg = first_or_none(callsite_ast.keywords)
        insert_str = f"gen={get_generated_name(func_or_class)}"
        if first_kwarg is not None:
            insert_pos = get_file_pos_from_line_col(
                first_kwarg.lineno,
                first_kwarg.col_offset,
                source_code,
            )
            insert_str = insert_str + ", "
        else:
            assert callsite_ast.end_lineno is not None
            assert callsite_ast.end_col_offset is not None
            insert_pos = (
                get_file_pos_from_line_col(
                    callsite_ast.end_lineno,
                    callsite_ast.end_col_offset,
                    source_code,
                )
                - 1  # just before the close parenth at the end of the function call
            )

        yield insert_pos, insert_str


def get_generated_name(func_or_class: Callable[..., Any] | type) -> str:
    if isinstance(func_or_class, type):
        return f"Gen{func_or_class.__name__}"
    else:
        return f"gen_{func_or_class.__name__}"


def maybe_insert_subclass_to_callsite_class_def(
    func_or_class: Callable[..., Any] | type,
    callsite_ast: EnhancedAST,
    source_code: str,
):
    """
    In cases where we're decorating a class, we need to insert the Gen... base class
    so that your code editor can use the macro-generated code for type checking.

    Note: we don't use `gen=...` kwarg in the class decorator because--
      1. default pylance behavior (in VSCode) is to ignore type annotations on class decorators
      2. (more importantly) we want to get type hints while we're writing methods for *this class*,
            so this class needs type hints from the macro-generated code.

    Note: avoiding `ast.unparse(...)` because it won't preserve comments or whitespace.
    """
    if isinstance(class_def := callsite_ast.parent, ast.ClassDef) and not one_or_none(
        base_class
        for base_class in class_def.bases
        if isinstance(base_class, ast.Name)
        and base_class.id == get_generated_name(func_or_class)
    ):
        has_class_args = bool(class_def.bases or class_def.keywords)

        insert_pos = (
            get_file_pos_from_line_col(
                class_def.lineno,
                class_def.col_offset,
                source_code,
            )
            + len("class ")
            + len(func_or_class.__name__)
        )
        insert_str = f"Gen{func_or_class.__name__}"

        if source_code[insert_pos] == ":":
            insert_str = f"({insert_str})"
        else:
            insert_pos += 1
        if has_class_args:
            insert_str += ", "
        yield insert_pos, insert_str


def import_from_path(module_name: str, file_path: str) -> Any:
    """https://docs.python.org/3/library/importlib.html#importing-programmatically"""
    spec = importlib.util.spec_from_file_location(module_name, file_path)  # type: ignore
    module = importlib.util.module_from_spec(spec)  # type: ignore
    sys.modules[module_name] = module
    spec.loader.exec_module(module)  # type: ignore
    return module  # type: ignore
